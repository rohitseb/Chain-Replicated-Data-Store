\batchmode %% Suppresses most terminal output.
\documentclass{article}
\usepackage{color}
\definecolor{boxshade}{gray}{0.85}
\setlength{\textwidth}{360pt}
\setlength{\textheight}{541pt}
\usepackage{latexsym}
\usepackage{ifthen}
% \usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SWITCHES                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{shading} 
\setboolean{shading}{false}
\makeatletter
 %% this is needed only when inserted into the file, not when
 %% used as a package file.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                           %
% DEFINITIONS OF SYMBOL-PRODUCING COMMANDS                                  %
%                                                                           %
%    TLA+      LaTeX                                                        %
%    symbol    command                                                      %
%    ------    -------                                                      %
%    =>        \implies                                                     %
%    <:        \ltcolon                                                     %
%    :>        \colongt                                                     %
%    ==        \defeq                                                       %
%    ..        \dotdot                                                      %
%    ::        \coloncolon                                                  %
%    =|        \eqdash                                                      %
%    ++        \pp                                                          %
%    --        \mm                                                          %
%    **        \stst                                                        %
%    //        \slsl                                                        %
%    ^         \ct                                                          %
%    \A        \A                                                           %
%    \E        \E                                                           %
%    \AA       \AA                                                          %
%    \EE       \EE                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\symlength}
\newcommand{\implies}{\Rightarrow}
\newcommand{\ltcolon}{\mathrel{<\!\!\mbox{:}}}
\newcommand{\colongt}{\mathrel{\!\mbox{:}\!\!>}}
\newcommand{\defeq}{\;\mathrel{\smash   %% keep this symbol from being too tall
    {{\stackrel{\scriptscriptstyle\Delta}{=}}}}\;}
\newcommand{\dotdot}{\mathrel{\ldotp\ldotp}}
\newcommand{\coloncolon}{\mathrel{::\;}}
\newcommand{\eqdash}{\mathrel = \joinrel \hspace{-.28em}|}
\newcommand{\pp}{\mathbin{++}}
\newcommand{\mm}{\mathbin{--}}
\newcommand{\stst}{*\!*}
\newcommand{\slsl}{/\!/}
\newcommand{\ct}{\hat{\hspace{.4em}}}
\newcommand{\A}{\forall}
\newcommand{\E}{\exists}
\renewcommand{\AA}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
   $\forall\hspace{-.517em}\forall\hspace{-.517em}\forall$}}%
   \forall\hspace{-.517em}\forall \hspace{-.517em}\forall\,$}}
\newcommand{\EE}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
   $\exists\hspace{-.517em}\exists\hspace{-.517em}\exists$}}%
   \exists\hspace{-.517em}\exists\hspace{-.517em}\exists\,$}}
\newcommand{\whileop}{\.{\stackrel
  {\mbox{\raisebox{-.3em}[0pt][0pt]{$\scriptscriptstyle+\;\,$}}}%
  {-\hspace{-.16em}\triangleright}}}

% Commands are defined to produce the upper-case keywords.
% Note that some have space after them.
\newcommand{\ASSUME}{\textsc{assume }}
\newcommand{\ASSUMPTION}{\textsc{assumption }}
\newcommand{\AXIOM}{\textsc{axiom }}
\newcommand{\BOOLEAN}{\textsc{boolean }}
\newcommand{\CASE}{\textsc{case }}
\newcommand{\CONSTANT}{\textsc{constant }}
\newcommand{\CONSTANTS}{\textsc{constants }}
\newcommand{\ELSE}{\settowidth{\symlength}{\THEN}%
   \makebox[\symlength][l]{\textsc{ else}}}
\newcommand{\EXCEPT}{\textsc{ except }}
\newcommand{\EXTENDS}{\textsc{extends }}
\newcommand{\FALSE}{\textsc{false}}
\newcommand{\IF}{\textsc{if }}
\newcommand{\IN}{\settowidth{\symlength}{\LET}%
   \makebox[\symlength][l]{\textsc{in}}}
\newcommand{\INSTANCE}{\textsc{instance }}
\newcommand{\LET}{\textsc{let }}
\newcommand{\LOCAL}{\textsc{local }}
\newcommand{\MODULE}{\textsc{module }}
\newcommand{\OTHER}{\textsc{other }}
\newcommand{\STRING}{\textsc{string}}
\newcommand{\THEN}{\textsc{ then }}
\newcommand{\THEOREM}{\textsc{theorem }}
\newcommand{\LEMMA}{\textsc{lemma }}
\newcommand{\PROPOSITION}{\textsc{proposition }}
\newcommand{\COROLLARY}{\textsc{corollary }}
\newcommand{\TRUE}{\textsc{true}}
\newcommand{\VARIABLE}{\textsc{variable }}
\newcommand{\VARIABLES}{\textsc{variables }}
\newcommand{\WITH}{\textsc{ with }}
\newcommand{\WF}{\textrm{WF}}
\newcommand{\SF}{\textrm{SF}}
\newcommand{\CHOOSE}{\textsc{choose }}
\newcommand{\ENABLED}{\textsc{enabled }}
\newcommand{\UNCHANGED}{\textsc{unchanged }}
\newcommand{\SUBSET}{\textsc{subset }}
\newcommand{\UNION}{\textsc{union }}
\newcommand{\DOMAIN}{\textsc{domain }}
% Added for tla2tex
\newcommand{\BY}{\textsc{by }}
\newcommand{\OBVIOUS}{\textsc{obvious }}
\newcommand{\HAVE}{\textsc{have }}
\newcommand{\QED}{\textsc{qed }}
\newcommand{\TAKE}{\textsc{take }}
\newcommand{\DEF}{\textsc{ def }}
\newcommand{\HIDE}{\textsc{hide }}
\newcommand{\RECURSIVE}{\textsc{recursive }}
\newcommand{\USE}{\textsc{use }}
\newcommand{\DEFINE}{\textsc{define }}
\newcommand{\PROOF}{\textsc{proof }}
\newcommand{\WITNESS}{\textsc{witness }}
\newcommand{\PICK}{\textsc{pick }}
\newcommand{\DEFS}{\textsc{defs }}
\newcommand{\PROVE}{\settowidth{\symlength}{\ASSUME}%
   \makebox[\symlength][l]{\textsc{prove}}\@s{-4.1}}%
  %% The \@s{-4.1) is a kludge added on 24 Oct 2009 [happy birthday, Ellen]
  %% so the correct alignment occurs if the user types
  %%   ASSUME X
  %%   PROVE  Y
  %% because it cancels the extra 4.1 pts added because of the 
  %% extra space after the PROVE.  This seems to works OK.
  %% However, the 4.1 equals Parameters.LaTeXLeftSpace(1) and
  %% should be changed if that method ever changes.
\newcommand{\SUFFICES}{\textsc{suffices }}
\newcommand{\NEW}{\textsc{new }}
\newcommand{\LAMBDA}{\textsc{lambda }}
\newcommand{\STATE}{\textsc{state }}
\newcommand{\ACTION}{\textsc{action }}
\newcommand{\TEMPORAL}{\textsc{temporal }}
\newcommand{\ONLY}{\textsc{only }}              %% added by LL on 2 Oct 2009
\newcommand{\OMITTED}{\textsc{omitted }}        %% added by LL on 31 Oct 2009
\newcommand{\@pfstepnum}[2]{\ensuremath{\langle#1\rangle}\textrm{#2}}
\newcommand{\bang}{\@s{1}\mbox{\small !}\@s{1}}
%% We should format || differently in PlusCal code than in TLA+ formulas.
\newcommand{\p@barbar}{\ifpcalsymbols
   \,\,\rule[-.25em]{.075em}{1em}\hspace*{.2em}\rule[-.25em]{.075em}{1em}\,\,%
   \else \,||\,\fi}
%% PlusCal keywords
\newcommand{\p@fair}{\textbf{fair }}
\newcommand{\p@semicolon}{\textbf{\,; }}
\newcommand{\p@algorithm}{\textbf{algorithm }}
\newcommand{\p@mmfair}{\textbf{-{}-fair }}
\newcommand{\p@mmalgorithm}{\textbf{-{}-algorithm }}
\newcommand{\p@assert}{\textbf{assert }}
\newcommand{\p@await}{\textbf{await }}
\newcommand{\p@begin}{\textbf{begin }}
\newcommand{\p@end}{\textbf{end }}
\newcommand{\p@call}{\textbf{call }}
\newcommand{\p@define}{\textbf{define }}
\newcommand{\p@do}{\textbf{ do }}
\newcommand{\p@either}{\textbf{either }}
\newcommand{\p@or}{\textbf{or }}
\newcommand{\p@goto}{\textbf{goto }}
\newcommand{\p@if}{\textbf{if }}
\newcommand{\p@then}{\,\,\textbf{then }}
\newcommand{\p@else}{\ifcsyntax \textbf{else } \else \,\,\textbf{else }\fi}
\newcommand{\p@elsif}{\,\,\textbf{elsif }}
\newcommand{\p@macro}{\textbf{macro }}
\newcommand{\p@print}{\textbf{print }}
\newcommand{\p@procedure}{\textbf{procedure }}
\newcommand{\p@process}{\textbf{process }}
\newcommand{\p@return}{\textbf{return}}
\newcommand{\p@skip}{\textbf{skip}}
\newcommand{\p@variable}{\textbf{variable }}
\newcommand{\p@variables}{\textbf{variables }}
\newcommand{\p@while}{\textbf{while }}
\newcommand{\p@when}{\textbf{when }}
\newcommand{\p@with}{\textbf{with }}
\newcommand{\p@lparen}{\textbf{(\,\,}}
\newcommand{\p@rparen}{\textbf{\,\,) }}   
\newcommand{\p@lbrace}{\textbf{\{\,\,}}   
\newcommand{\p@rbrace}{\textbf{\,\,\} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REDEFINE STANDARD COMMANDS TO MAKE THEM FORMAT BETTER %
%                                                       %
% We redefine \in and \notin                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\_}{\rule{.4em}{.06em}\hspace{.05em}}
\newlength{\equalswidth}
\let\oldin=\in
\let\oldnotin=\notin
\renewcommand{\in}{%
   {\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth][c]{$\oldin$}}}
\renewcommand{\notin}{%
   {\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth]{$\oldnotin$}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                  %
% HORIZONTAL BARS:                                 %
%                                                  %
%   \moduleLeftDash    |~~~~~~~~~~                 %
%   \moduleRightDash    ~~~~~~~~~~|                %
%   \midbar            |----------|                %
%   \bottombar         |__________|                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\charwidth}\settowidth{\charwidth}{{\small\tt M}}
\newlength{\boxrulewd}\setlength{\boxrulewd}{.4pt}
\newlength{\boxlineht}\setlength{\boxlineht}{.5\baselineskip}
\newcommand{\boxsep}{\charwidth}
\newlength{\boxruleht}\setlength{\boxruleht}{.5ex}
\newlength{\boxruledp}\setlength{\boxruledp}{-\boxruleht}
\addtolength{\boxruledp}{\boxrulewd}
\newcommand{\boxrule}{\leaders\hrule height \boxruleht depth \boxruledp
                      \hfill\mbox{}}
\newcommand{\@computerule}{%
  \setlength{\boxruleht}{.5ex}%
  \setlength{\boxruledp}{-\boxruleht}%
  \addtolength{\boxruledp}{\boxrulewd}}

\newcommand{\bottombar}{\hspace{-\boxsep}%
  \raisebox{-\boxrulewd}[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}%
  \boxrule
  \raisebox{-\boxrulewd}[0pt][0pt]{%
      \rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}\vspace{0pt}}

\newcommand{\moduleLeftDash}%
   {\hspace*{-\boxsep}%
     \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
               }{\boxlineht}}%
    \boxrule\hspace*{.4em }}

\newcommand{\moduleRightDash}%
    {\hspace*{.4em}\boxrule
    \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
               }{\boxlineht}}\hspace{-\boxsep}}%\vspace{.2em}

\newcommand{\midbar}{\hspace{-\boxsep}\raisebox{-.5\boxlineht}[0pt][0pt]{%
   \rule[.5ex]{\boxrulewd}{\boxlineht}}\boxrule\raisebox{-.5\boxlineht%
   }[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORMATING COMMANDS                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLUSCAL SHADING                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The TeX pcalshading switch is set on to cause PlusCal shading to be
% performed.  This changes the behavior of the following commands and
% environments to cause full-width shading to be performed on all lines.
% 
%   \tstrut \@x cpar mcom \@pvspace
% 
% The TeX pcalsymbols switch is turned on when typesetting a PlusCal algorithm,
% whether or not shading is being performed.  It causes symbols (other than
% parentheses and braces and PlusCal-only keywords) that should be typeset
% differently depending on whether they are in an algorithm to be typeset
% appropriately.  Currently, the only such symbol is "||".
%
% The TeX csyntax switch is turned on when typesetting a PlusCal algorithm in
% c-syntax.  This allows symbols to be format differently in the two syntaxes.
% The "else" keyword is the only one that is.

\newif\ifpcalshading \pcalshadingfalse
\newif\ifpcalsymbols \pcalsymbolsfalse
\newif\ifcsyntax     \csyntaxtrue

% The \@pvspace command makes a vertical space.  It uses \vspace
% except with \ifpcalshading, in which case it sets \pvcalvspace
% and the space is added by a following \@x command.
%
\newlength{\pcalvspace}\setlength{\pcalvspace}{0pt}%
\newcommand{\@pvspace}[1]{%
  \ifpcalshading
     \par\global\setlength{\pcalvspace}{#1}%
  \else
     \par\vspace{#1}%
  \fi
}

% The lcom environment was changed to set \lcomindent equal to
% the indentation it produces.  This length is used by the
% cpar environment to make shading extend for the full width
% of the line.  This assumes that lcom environments are not
% nested.  I hope TLATeX does not nest them.
%
\newlength{\lcomindent}%
\setlength{\lcomindent}{0pt}%

%\tstrut: A strut to produce inter-paragraph space in a comment.
%\rstrut: A strut to extend the bottom of a one-line comment so
%         there's no break in the shading between comments on 
%         successive lines.
\newcommand\tstrut%
  {\raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{1.15em}}}%
   \global\setlength{\vshadelen}{0pt}}
\newcommand\rstrut{\raisebox{-.25em}{\rule{0pt}{1.15em}}%
 \global\setlength{\vshadelen}{0pt}}


% \.{op} formats operator op in math mode with empty boxes on either side.
% Used because TeX otherwise vary the amount of space it leaves around op.
\renewcommand{\.}[1]{\ensuremath{\mbox{}#1\mbox{}}}

% \@s{n} produces an n-point space
\newcommand{\@s}[1]{\hspace{#1pt}}           

% \@x{txt} starts a specification line in the beginning with txt
% in the final LaTeX source.
\newlength{\@xlen}
\newcommand\xtstrut%
  {\setlength{\@xlen}{1.05em}%
   \addtolength{\@xlen}{\pcalvspace}%
    \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\@xlen}}}%
   \global\setlength{\vshadelen}{0pt}%
   \global\setlength{\pcalvspace}{0pt}}

\newcommand{\@x}[1]{\par
  \ifpcalshading
  \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
  \fi
  \mbox{$\mbox{}#1\mbox{}$}}  

% \@xx{txt} continues a specification line with the text txt.
\newcommand{\@xx}[1]{\mbox{$\mbox{}#1\mbox{}$}}  

% \@y{cmt} produces a one-line comment.
\newcommand{\@y}[1]{\mbox{\footnotesize\hspace{.65em}%
  \ifthenelse{\boolean{shading}}{%
      \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
               {#1\hspace{-\the\lastskip}\rstrut}}}

% \@z{cmt} produces a zero-width one-line comment.
\newcommand{\@z}[1]{\makebox[0pt][l]{\footnotesize
  \ifthenelse{\boolean{shading}}{%
      \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
               {#1\hspace{-\the\lastskip}\rstrut}}}


% \@w{str} produces the TLA+ string "str".
\newcommand{\@w}[1]{\textsf{``{#1}''}}             


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SHADING                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\graymargin{1}
  % The number of points of margin in the shaded box.

% \definecolor{boxshade}{gray}{.85}
% Defines the darkness of the shading: 1 = white, 0 = black
% Added by TLATeX only if needed.

% \shadebox{txt} puts txt in a shaded box.
\newlength{\templena}
\newlength{\templenb}
\newsavebox{\tempboxa}
\newcommand{\shadebox}[1]{{\setlength{\fboxsep}{\graymargin pt}%
     \savebox{\tempboxa}{#1}%
     \settoheight{\templena}{\usebox{\tempboxa}}%
     \settodepth{\templenb}{\usebox{\tempboxa}}%
     \hspace*{-\fboxsep}\raisebox{0pt}[\templena][\templenb]%
        {\colorbox{boxshade}{\usebox{\tempboxa}}}\hspace*{-\fboxsep}}}

% \vshade{n} makes an n-point inter-paragraph space, with
%  shading if the `shading' flag is true.
\newlength{\vshadelen}
\setlength{\vshadelen}{0pt}
\newcommand{\vshade}[1]{\ifthenelse{\boolean{shading}}%
   {\global\setlength{\vshadelen}{#1pt}}%
   {\vspace{#1pt}}}

\newlength{\boxwidth}
\newlength{\multicommentdepth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE cpar ENVIRONMENT                                                      %
% ^^^^^^^^^^^^^^^^^^^^                                                      %
% The LaTeX input                                                           %
%                                                                           %
%   \begin{cpar}{pop}{nest}{isLabel}{d}{e}{arg6}                            %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%   \end{cpar}                                                              %
%                                                                           %
% produces one of two possible results.  If isLabel is the letter "T",      %
% it produces the following, where [label] is the result of typesetting     %
% arg6 in an LR box, and d is is a number representing a distance in        %
% points.                                                                   %
%                                                                           %
%   prevailing |<-- d -->[label]<- e ->XXXXXXXXXXXXXXX                      %
%         left |                       XXXXXXXXXXXXXXX                      %
%       margin |                       XXXXXXXXXXXXXXX                      %
%                                                                           %
% If isLabel is the letter "F", then it produces                            %
%                                                                           %
%   prevailing |<-- d -->XXXXXXXXXXXXXXXXXXXXXXX                            %
%         left |         <- e ->XXXXXXXXXXXXXXXX                            %
%       margin |                XXXXXXXXXXXXXXXX                            %
%                                                                           %
% where d and e are numbers representing distances in points.               %
%                                                                           %
% The prevailing left margin is the one in effect before the most recent    %
% pop (argument 1) cpar environments with "T" as the nest argument, where   %
% pop is a number \geq 0.                                                   %
%                                                                           %
% If the nest argument is the letter "T", then the prevailing left          %
% margin is moved to the left of the second (and following) lines of        %
% X's.  Otherwise, the prevailing left margin is left unchanged.            %
%                                                                           %
% An \unnest{n} command moves the prevailing left margin to where it was    %
% before the most recent n cpar environments with "T" as the nesting        %
% argument.                                                                 %
%                                                                           %
% The environment leaves no vertical space above or below it, or between    %
% its paragraphs.  (TLATeX inserts the proper amount of vertical space.)    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcounter{pardepth}
\setcounter{pardepth}{0}

% \setgmargin{txt} defines \gmarginN to be txt, where N is \roman{pardepth}.
% \thegmargin equals \gmarginN, where N is \roman{pardepth}.
\newcommand{\setgmargin}[1]{%
  \expandafter\xdef\csname gmargin\roman{pardepth}\endcsname{#1}}
\newcommand{\thegmargin}{\csname gmargin\roman{pardepth}\endcsname}
\newcommand{\gmargin}{0pt}

\newsavebox{\tempsbox}

\newlength{\@cparht}
\newlength{\@cpardp}
\newenvironment{cpar}[6]{%
  \addtocounter{pardepth}{-#1}%
  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
                                 \begin{minipage}[t]{\linewidth}}{}%
  \begin{list}{}{%
     \edef\temp{\thegmargin}
     \ifthenelse{\equal{#3}{T}}%
       {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
        \addtolength{\leftmargin}{#4pt}}%
       {\setlength{\leftmargin}{#4pt}%
        \addtolength{\leftmargin}{#5pt}%
        \addtolength{\leftmargin}{\temp}%
        \setlength{\itemindent}{-#5pt}}%
      \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
                                 \setgmargin{\the\leftmargin}}{}%
      \setlength{\labelwidth}{0pt}%
      \setlength{\labelsep}{0pt}%
      \setlength{\itemindent}{-\leftmargin}%
      \setlength{\topsep}{0pt}%
      \setlength{\parsep}{0pt}%
      \setlength{\partopsep}{0pt}%
      \setlength{\parskip}{0pt}%
      \setlength{\itemsep}{0pt}
      \setlength{\itemindent}{#4pt}%
      \addtolength{\itemindent}{-\leftmargin}}%
   \ifthenelse{\equal{#3}{T}}%
      {\item[\tstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]
        }%
      {\item[\tstrut\hspace{\temp}]%
         }%
   \footnotesize}
 {\hspace{-\the\lastskip}\tstrut
 \end{list}%
  \ifthenelse{\boolean{shading}}%
          {\end{minipage}%
           \end{lrbox}%
           \ifpcalshading
             \setlength{\@cparht}{\ht\tempsbox}%
             \setlength{\@cpardp}{\dp\tempsbox}%
             \addtolength{\@cparht}{.15em}%
             \addtolength{\@cpardp}{.2em}%
             \addtolength{\@cparht}{\@cpardp}%
            % I don't know what's going on here.  I want to add a
            % \pcalvspace high shaded line, but I don't know how to
            % do it.  A little trial and error shows that the following
            % does a reasonable job approximating that, eliminating
            % the line if \pcalvspace is small.
            \addtolength{\@cparht}{\pcalvspace}%
             \ifdim \pcalvspace > .8em
               \addtolength{\pcalvspace}{-.2em}%
               \hspace*{-\lcomindent}%
               \shadebox{\rule{0pt}{\pcalvspace}\hspace*{\textwidth}}\par
               \global\setlength{\pcalvspace}{0pt}%
               \fi
             \hspace*{-\lcomindent}%
             \makebox[0pt][l]{\raisebox{-\@cpardp}[0pt][0pt]{%
                 \shadebox{\rule{0pt}{\@cparht}\hspace*{\textwidth}}}}%
             \hspace*{\lcomindent}\usebox{\tempsbox}%
             \par
           \else
             \shadebox{\usebox{\tempsbox}}\par
           \fi}%
           {}%
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE ppar ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% The environment                                                            %
%                                                                            %
%   \begin{ppar} ... \end{ppar}                                              %
%                                                                            %
% is equivalent to                                                           %
%                                                                            %
%   \begin{cpar}{0}{F}{F}{0}{0}{} ... \end{cpar}                             %
%                                                                            %
% The environment is put around each line of the output for a PlusCal        %
% algorithm.                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newenvironment{ppar}{%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}
%        \setlength{\leftmargin}{0pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{0pt}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}
%      \setlength{\itemindent}{0pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%      \item[\tstrut\hspace{\temp}]}%
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \shadebox{\usebox{\tempsbox}}\par}{}%
%  }

 %%% TESTING
 \newcommand{\xtest}[1]{\par
 \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
 \mbox{$\mbox{}#1\mbox{}$}} 

% \newcommand{\xxtest}[1]{\par
% \makebox[0pt][l]{\shadebox{\xtstrut{#1}\hspace*{\textwidth}}}%
% \mbox{$\mbox{}#1\mbox{}$}} 

%\newlength{\pcalvspace}
%\setlength{\pcalvspace}{0pt}
% \newlength{\xxtestlen}
% \setlength{\xxtestlen}{0pt}
% \newcommand\xtstrut%
%   {\setlength{\xxtestlen}{1.15em}%
%    \addtolength{\xxtestlen}{\pcalvspace}%
%     \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\xxtestlen}}}%
%    \global\setlength{\vshadelen}{0pt}%
%    \global\setlength{\pcalvspace}{0pt}}
   
   %%%% TESTING
   
   %% The xcpar environment
   %%  Note: overloaded use of \pcalvspace for testing.
   %%
%   \newlength{\xcparht}%
%   \newlength{\xcpardp}%
   
%   \newenvironment{xcpar}[6]{%
%  \addtocounter{pardepth}{-#1}%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}%
%     \ifthenelse{\equal{#3}{T}}%
%       {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
%        \addtolength{\leftmargin}{#4pt}}%
%       {\setlength{\leftmargin}{#4pt}%
%        \addtolength{\leftmargin}{#5pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{-#5pt}}%
%      \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
%                                 \setgmargin{\the\leftmargin}}{}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}%
%      \setlength{\itemindent}{#4pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%   \ifthenelse{\equal{#3}{T}}%
%      {\item[\xtstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]%
%        }%
%      {\item[\xtstrut\hspace{\temp}]%
%         }%
%   \footnotesize}
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \setlength{\xcparht}{\ht\tempsbox}%
%                                 \setlength{\xcpardp}{\dp\tempsbox}%
%                                 \addtolength{\xcparht}{.15em}%
%                                 \addtolength{\xcpardp}{.2em}%
%                                 \addtolength{\xcparht}{\xcpardp}%
%                                 \hspace*{-\lcomindent}%
%                                 \makebox[0pt][l]{\raisebox{-\xcpardp}[0pt][0pt]{%
%                                      \shadebox{\rule{0pt}{\xcparht}\hspace*{\textwidth}}}}%
%                                 \hspace*{\lcomindent}\usebox{\tempsbox}%
%                                 \par}{}%
%  }
%  
% \newlength{\xmcomlen}
%\newenvironment{xmcom}[1]{%
%  \setcounter{pardepth}{0}%
%  \hspace{.65em}%
%  \begin{lrbox}{\alignbox}\sloppypar%
%      \setboolean{shading}{false}%
%      \setlength{\boxwidth}{#1pt}%
%      \addtolength{\boxwidth}{-.65em}%
%      \begin{minipage}[t]{\boxwidth}\footnotesize
%      \parskip=0pt\relax}%
%       {\end{minipage}\end{lrbox}%
%       \setlength{\xmcomlen}{\textwidth}%
%       \addtolength{\xmcomlen}{-\wd\alignbox}%
%       \settodepth{\alignwidth}{\usebox{\alignbox}}%
%       \global\setlength{\multicommentdepth}{\alignwidth}%
%       \setlength{\boxwidth}{\alignwidth}%
%       \global\addtolength{\alignwidth}{-\maxdepth}%
%       \addtolength{\boxwidth}{.1em}%
%       \raisebox{0pt}[0pt][0pt]{%
%        \ifthenelse{\boolean{shading}}%
%          {\hspace*{-\xmcomlen}\shadebox{\rule[-\boxwidth]{0pt}{0pt}%
%                                 \hspace*{\xmcomlen}\usebox{\alignbox}}}%
%          {\usebox{\alignbox}}}%
%       \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
% % a multi-line comment, whose first argument is its width in points.
%  
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE lcom ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% A multi-line comment with no text to its left is typeset in an lcom        % 
% environment, whose argument is a number representing the indentation       % 
% of the left margin, in points.  All the text of the comment should be      % 
% inside cpar environments.                                                  % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{lcom}[1]{%
  \setlength{\lcomindent}{#1pt} % Added for PlusCal handling.
  \par\vspace{.2em}%
  \sloppypar
  \setcounter{pardepth}{0}%
  \footnotesize
  \begin{list}{}{%
    \setlength{\leftmargin}{#1pt}
    \setlength{\labelwidth}{0pt}%
    \setlength{\labelsep}{0pt}%
    \setlength{\itemindent}{0pt}%
    \setlength{\topsep}{0pt}%
    \setlength{\parsep}{0pt}%
    \setlength{\partopsep}{0pt}%
    \setlength{\parskip}{0pt}}
    \item[]}%
  {\end{list}\vspace{.3em}\setlength{\lcomindent}{0pt}%
 }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE mcom ENVIRONMENT AND \mutivspace COMMAND                              %
% ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                              %
%                                                                           %
% A part of the spec containing a right-comment of the form                 %
%                                                                           %
%      xxxx (*************)                                                 %
%      yyyy (* ccccccccc *)                                                 %
%      ...  (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (*************)                                                 %
%                                                                           %
% is typeset by                                                             %
%                                                                           %
%     XXXX \begin{mcom}{d}                                                  %
%            CCCC ... CCC                                                   %
%          \end{mcom}                                                       %
%     YYYY ...                                                              %
%     \multivspace{n}                                                       %
%                                                                           %
% where the number d is the width in points of the comment, n is the        %
% number of xxxx, yyyy, ...  lines to the left of the comment.              %
% All the text of the comment should be typeset in cpar environments.       %
%                                                                           %
% This puts the comment into a single box (so no page breaks can occur      %
% within it).  The entire box is shaded iff the shading flag is true.       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\xmcomlen}%
\newenvironment{mcom}[1]{%
  \setcounter{pardepth}{0}%
  \hspace{.65em}%
  \begin{lrbox}{\alignbox}\sloppypar%
      \setboolean{shading}{false}%
      \setlength{\boxwidth}{#1pt}%
      \addtolength{\boxwidth}{-.65em}%
      \begin{minipage}[t]{\boxwidth}\footnotesize
      \parskip=0pt\relax}%
       {\end{minipage}\end{lrbox}%
       \setlength{\xmcomlen}{\textwidth}%       % For PlusCal shading
       \addtolength{\xmcomlen}{-\wd\alignbox}%  % For PlusCal shading
       \settodepth{\alignwidth}{\usebox{\alignbox}}%
       \global\setlength{\multicommentdepth}{\alignwidth}%
       \setlength{\boxwidth}{\alignwidth}%      % For PlusCal shading
       \global\addtolength{\alignwidth}{-\maxdepth}%
       \addtolength{\boxwidth}{.1em}%           % For PlusCal shading
      \raisebox{0pt}[0pt][0pt]{%
        \ifthenelse{\boolean{shading}}%
          {\ifpcalshading
             \hspace*{-\xmcomlen}%
             \shadebox{\rule[-\boxwidth]{0pt}{0pt}\hspace*{\xmcomlen}%
                          \usebox{\alignbox}}%
           \else
             \shadebox{\usebox{\alignbox}}
           \fi
          }%
          {\usebox{\alignbox}}}%
       \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
 % a multi-line comment, whose first argument is its width in points.


% \multispace{n} produces the vertical space indicated by "|"s in 
% this situation
%   
%     xxxx (*************)
%     xxxx (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (*************)
%
% where n is the number of "xxxx" lines.
\newcommand{\multivspace}[1]{\addtolength{\multicommentdepth}{-#1\baselineskip}%
 \addtolength{\multicommentdepth}{1.2em}%
 \ifthenelse{\lengthtest{\multicommentdepth > 0pt}}%
    {\par\vspace{\multicommentdepth}\par}{}}

%\newenvironment{hpar}[2]{%
%  \begin{list}{}{\setlength{\leftmargin}{#1pt}%
%                 \addtolength{\leftmargin}{#2pt}%
%                 \setlength{\itemindent}{-#2pt}%
%                 \setlength{\topsep}{0pt}%
%                 \setlength{\parsep}{0pt}%
%                 \setlength{\partopsep}{0pt}%
%                 \setlength{\parskip}{0pt}%
%                 \addtolength{\labelsep}{0pt}}%
%  \item[]\footnotesize}{\end{list}}
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    % Typesets a sequence of paragraphs like this:                         %
%    %                                                                      %
%    %      left |<-- d1 --> XXXXXXXXXXXXXXXXXXXXXXXX                       %
%    %    margin |           <- d2 -> XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                                                          %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %                                                                      %
%    % where d1 = #1pt and d2 = #2pt, but with no vspace between            %
%    % paragraphs.                                                          %
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Commands for repeated characters that produce dashes.              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raisedDash{wd}{ht}{thk} makes a horizontal line wd characters wide, 
% raised a distance ht ex's above the baseline, with a thickness of 
% thk em's.
\newcommand{\raisedDash}[3]{\raisebox{#2ex}{\setlength{\alignwidth}{.5em}%
  \rule{#1\alignwidth}{#3em}}}

% The following commands take a single argument n and produce the
% output for n repeated characters, as follows
%   \cdash:    -
%   \tdash:    ~
%   \ceqdash:  =
%   \usdash:   _
\newcommand{\cdash}[1]{\raisedDash{#1}{.5}{.04}}
\newcommand{\usdash}[1]{\raisedDash{#1}{0}{.04}}
\newcommand{\ceqdash}[1]{\raisedDash{#1}{.5}{.08}}
\newcommand{\tdash}[1]{\raisedDash{#1}{1}{.08}}

\newlength{\spacewidth}
\setlength{\spacewidth}{.2em}
\newcommand{\e}[1]{\hspace{#1\spacewidth}}
%% \e{i} produces space corresponding to i input spaces.


%% Alignment-file Commands

\newlength{\alignboxwidth}
\newlength{\alignwidth}
\newsavebox{\alignbox}

% \al{i}{j}{txt} is used in the alignment file to put "%{i}{j}{wd}"
% in the log file, where wd is the width of the line up to that point,
% and txt is the following text.
\newcommand{\al}[3]{%
  \typeout{\%{#1}{#2}{\the\alignwidth}}%
  \cl{#3}}

%% \cl{txt} continues a specification line in the alignment file
%% with text txt.
\newcommand{\cl}[1]{%
  \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
  \settowidth{\alignboxwidth}{\usebox{\alignbox}}%
  \addtolength{\alignwidth}{\alignboxwidth}%
  \usebox{\alignbox}}

% \fl{txt} in the alignment file begins a specification line that
% starts with the text txt.
\newcommand{\fl}[1]{%
  \par
  \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
  \settowidth{\alignwidth}{\usebox{\alignbox}}%
  \usebox{\alignbox}}



  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ordinarily, TeX typesets letters in math mode in a special math italic    %
% font.  This makes it typeset "it" to look like the product of the         %
% variables i and t, rather than like the word "it".  The following         %
% commands tell TeX to use an ordinary italic font instead.                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifx\documentclass\undefined
\else
  \DeclareSymbolFont{tlaitalics}{\encodingdefault}{cmr}{m}{it}
  \let\itfam\symtlaitalics
\fi

\makeatletter
\newcommand{\tlx@c}{\c@tlx@ctr\advance\c@tlx@ctr\@ne}
\newcounter{tlx@ctr}
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7061\relax
\mathcode`a=\tlx@c \mathcode`b=\tlx@c \mathcode`c=\tlx@c \mathcode`d=\tlx@c
\mathcode`e=\tlx@c \mathcode`f=\tlx@c \mathcode`g=\tlx@c \mathcode`h=\tlx@c
\mathcode`i=\tlx@c \mathcode`j=\tlx@c \mathcode`k=\tlx@c \mathcode`l=\tlx@c
\mathcode`m=\tlx@c \mathcode`n=\tlx@c \mathcode`o=\tlx@c \mathcode`p=\tlx@c
\mathcode`q=\tlx@c \mathcode`r=\tlx@c \mathcode`s=\tlx@c \mathcode`t=\tlx@c
\mathcode`u=\tlx@c \mathcode`v=\tlx@c \mathcode`w=\tlx@c \mathcode`x=\tlx@c
\mathcode`y=\tlx@c \mathcode`z=\tlx@c
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7041\relax
\mathcode`A=\tlx@c \mathcode`B=\tlx@c \mathcode`C=\tlx@c \mathcode`D=\tlx@c
\mathcode`E=\tlx@c \mathcode`F=\tlx@c \mathcode`G=\tlx@c \mathcode`H=\tlx@c
\mathcode`I=\tlx@c \mathcode`J=\tlx@c \mathcode`K=\tlx@c \mathcode`L=\tlx@c
\mathcode`M=\tlx@c \mathcode`N=\tlx@c \mathcode`O=\tlx@c \mathcode`P=\tlx@c
\mathcode`Q=\tlx@c \mathcode`R=\tlx@c \mathcode`S=\tlx@c \mathcode`T=\tlx@c
\mathcode`U=\tlx@c \mathcode`V=\tlx@c \mathcode`W=\tlx@c \mathcode`X=\tlx@c
\mathcode`Y=\tlx@c \mathcode`Z=\tlx@c
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                THE describe ENVIRONMENT                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% It is like the description environment except it takes an argument
% ARG that should be the text of the widest label.  It adjusts the
% indentation so each item with label LABEL produces
%%      LABEL             blah blah blah
%%      <- width of ARG ->blah blah blah
%%                        blah blah blah
\newenvironment{describe}[1]%
   {\begin{list}{}{\settowidth{\labelwidth}{#1}%
            \setlength{\labelsep}{.5em}%
            \setlength{\leftmargin}{\labelwidth}% 
            \addtolength{\leftmargin}{\labelsep}%
            \addtolength{\leftmargin}{\parindent}%
            \def\makelabel##1{\rm ##1\hfill}}%
            \setlength{\topsep}{0pt}}%% 
                % Sets \topsep to 0 to reduce vertical space above
                % and below embedded displayed equations
   {\end{list}}

%   For tlatex.TeX
\usepackage{verbatim}
\makeatletter
\def\tla{\let\%\relax%
         \@bsphack
         \typeout{\%{\the\linewidth}}%
             \let\do\@makeother\dospecials\catcode`\^^M\active
             \let\verbatim@startline\relax
             \let\verbatim@addtoline\@gobble
             \let\verbatim@processline\relax
             \let\verbatim@finish\relax
             \verbatim@}
\let\endtla=\@esphack

\let\pcal=\tla
\let\endpcal=\endtla
\let\ppcal=\tla
\let\endppcal=\endtla

% The tlatex environment is used by TLATeX.TeX to typeset TLA+.
% TLATeX.TLA starts its files by writing a \tlatex command.  This
% command/environment sets \parindent to 0 and defines \% to its
% standard definition because the writing of the log files is messed up
% if \% is defined to be something else.  It also executes
% \@computerule to determine the dimensions for the TLA horizonatl
% bars.
\newenvironment{tlatex}{\@computerule%
                        \setlength{\parindent}{0pt}%
                       \makeatletter\chardef\%=`\%}{}


% The notla environment produces no output.  You can turn a 
% tla environment to a notla environment to prevent tlatex.TeX from
% re-formatting the environment.

\def\notla{\let\%\relax%
         \@bsphack
             \let\do\@makeother\dospecials\catcode`\^^M\active
             \let\verbatim@startline\relax
             \let\verbatim@addtoline\@gobble
             \let\verbatim@processline\relax
             \let\verbatim@finish\relax
             \verbatim@}
\let\endnotla=\@esphack

\let\nopcal=\notla
\let\endnopcal=\endnotla
\let\noppcal=\notla
\let\endnoppcal=\endnotla

%%%%%%%%%%%%%%%%%%%%%%%% end of tlatex.sty file %%%%%%%%%%%%%%%%%%%%%%% 
% last modified on Fri  3 August 2012 at 14:23:49 PST by lamport

\begin{document}
\tlatex
\setboolean{shading}{true}
\@x{}\moduleLeftDash\@xx{ {\MODULE} voldchain}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Integers ,\, Sequences ,\, FiniteSets ,\, TLC}%
\@x{ {\CONSTANTS} N ,\, C ,\, STOP ,\, FAILNUM}%
 \@x{ {\ASSUME} N \.{-} FAILNUM \.{\geq} 1 \.{\land} STOP \.{<} 5 \.{\land}
 \.{\land} 0 \.{\leq} FAILNUM \.{\land} FAILNUM \.{\leq} 2}%
\@x{ Nodes \.{\defeq} 1 \.{\dotdot} N}%
\@x{ Clients \.{\defeq} N \.{+} 1 \.{\dotdot} N \.{+} C}%
\@x{ Procs \.{\defeq} 1 \.{\dotdot} N \.{+} C}%
\@x{ Configurator \.{\defeq} N \.{+} C \.{+} 1}%
\@pvspace{8.0pt}%
\pcalsymbolstrue
\pcalshadingtrue
\csyntaxtrue
\@x{ {\p@mmalgorithm} test {\p@lbrace}}%
 \@x{\@s{16.4} {\p@variable} FailNum \.{=} FAILNUM ,\, step \.{=} 0 ,\, LSTWR
 \.{=} \.{-} 1 ,\, CURRD \.{=} \.{-} 1 ,\, lsttmp \.{=} \.{-} 1 ,\, WRTFLG
 \.{=} \.{-} 1 ,\,}%
 \@x{\@s{71.92} msg \.{=} [ j \.{\in} Procs \.{\mapsto} {\langle} {\rangle} ]
 ,\,}%
\@x{\@s{71.92} up \.{=} [ n \.{\in} Nodes \.{\mapsto} {\TRUE} ] ,\,}%
 \@x{\@s{71.92} db\@s{0.76} \.{=} [ n \.{\in} Nodes \.{\mapsto} [ ver
 \.{\mapsto} \.{-} 1 ,\, val \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto} \.{-} 1
 ] ] ,\,}%
\@x{\@s{71.92} chain \.{=} {\langle} {\rangle} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{\@s{16.4} {\p@define}}%
\@x{\@s{16.4} {\p@lbrace}}%
\@pvspace{8.0pt}%
 \@x{\@s{32.8} UpNodes \.{\defeq} \{ i \.{\in} Nodes \.{:} up [ i ] \.{=}
 {\TRUE} \}\@s{4.1}}%
\@y{\@s{0}%
 Returns the set of up nodes
}%
\@xx{}%
 \@x{\@s{32.8} ChainNode \.{\defeq} \{ chain [ i ] \.{:} i \.{\in} 1
 \.{\dotdot} Len ( chain ) \}\@s{4.1}}%
\@y{\@s{0}%
 Returns the elements in the chain as set
}%
\@xx{}%
 \@x{\@s{32.8} ChainNodes \.{\defeq} {\IF} ( Len ( chain ) \.{=} 0 ) \.{\THEN}
 \{ \.{-} 1 \} \.{\ELSE} ChainNode\@s{4.1}}%
\@y{\@s{0}%
 Retruns \ensuremath{\{\.{-}1\}} if chain is empty else the set of chain
}%
\@xx{}%
 \@x{\@s{32.8} InChain ( s )\@s{3.72} \.{\defeq} {\IF} ( s \.{\in} ChainNodes
 ) \.{\THEN} {\TRUE} \.{\ELSE} {\FALSE}}%
\@y{\@s{0}%
 Check if the element is on chain
}%
\@xx{}%
 \@x{\@s{32.8} FreeUpNodes \.{\defeq} \{ i \.{\in} UpNodes \.{:} InChain ( i )
 \.{=} {\FALSE} \.{\land} up [ i ] \.{=} {\TRUE} \}\@s{4.1}}%
\@y{\@s{0}%
 Retrun set of upnodes that are not in chain
}%
\@xx{}%
 \@x{\@s{32.8} GetIndex ( s )\@s{3.97} \.{\defeq} {\CHOOSE} i \.{\in} 1
 \.{\dotdot} Len ( chain ) \.{:} chain [ i ] \.{=} s\@s{4.1}}%
\@y{\@s{0}%
 Get the index position of \ensuremath{s} in chain
}%
\@xx{}%
 \@x{\@s{32.8} GetNext ( s ) \.{\defeq} {\IF} ( GetIndex ( s ) \.{=} Len (
 chain ) ) \.{\THEN} \.{-} 1 \.{\ELSE} chain [ GetIndex ( s ) \.{+} 1 ]}%
\@y{\@s{0}%
 Get the successor on chain
}%
\@xx{}%
 \@x{\@s{32.8} GetFreeNode \.{\defeq} \{ i \.{\in} FreeUpNodes \.{:} up [ i ]
 \.{=} {\TRUE} \}}%
\@x{\@s{32.8} GetTail\@s{4.62} \.{\defeq} chain [ Len ( chain ) ]\@s{188.59}}%
\@y{\@s{0}%
 Get the tail of chain
}%
\@xx{}%
\@x{\@s{32.8} GetHead \.{\defeq} chain [ 1 ]}%
 \@x{\@s{32.8} test ( e )\@s{9.02} \.{\defeq} {\IF} ( up [ e ] \.{=} {\TRUE} )
 \.{\THEN} {\TRUE} \.{\ELSE} {\FALSE}\@s{192.7}}%
\@y{\@s{0}%
 Get the head of chain
}%
\@xx{}%
\@x{\@s{16.4} {\p@rbrace}}%
\@pvspace{8.0pt}%
 \@x{\@s{16.4} {\p@fair} {\p@process} {\p@lparen} c \.{\in} Clients
 {\p@rparen}}%
 \@x{\@s{16.4} {\p@variable} cntr \.{=} 0 ,\, hver \.{=} \.{-} 1 ,\, lastelm
 \.{=} 0 ,\, tail \.{=} \.{-} 1 ,\, head \.{=} \.{-} 1 ,\, initial \.{=} 0
 {\p@semicolon}}%
\@x{\@s{16.4} {\p@lbrace}}%
 \@x{\@s{32.8} C0\@s{.5}\textrm{:}\@s{3} {\p@await} ( Len ( chain ) \.{>} 0 )
 {\p@semicolon}}%
 \@x{\@s{32.8} CL\@s{.5}\textrm{:}\@s{3}\@s{0.18} {\p@while} {\p@lparen} cntr
 \.{\leq} STOP {\p@rparen}}%
\@x{\@s{32.8} {\p@lbrace}}%
\@x{\@s{41.0} CLR\@s{.5}\textrm{:}\@s{3}}%
 \@x{\@s{41.0} {\p@while} {\p@lparen} WRTFLG \.{\neq} self
 {\p@rparen}\@s{4.1}}%
\@y{\@s{0}%
 Iterate through read request
}%
\@xx{}%
\@x{\@s{41.0} {\p@lbrace}}%
 \@x{\@s{49.2} {\p@if} {\p@lparen} msg [ self ] \.{\neq} {\langle} {\rangle}
 {\p@rparen}}%
\@x{\@s{49.2} {\p@lbrace}}%
 \@x{\@s{57.4} {\p@if} {\p@lparen} msg [ self ] . val \.{=} \.{-} 1
 {\p@rparen}}%
\@x{\@s{57.4} {\p@lbrace}}%
\@x{\@s{65.6} hver \.{:=} msg [ self ] . ver \.{+} 1 {\p@semicolon}}%
 \@x{\@s{73.79} CURRD \.{:=} db [ chain [ Len ( chain ) ] ] . ver
 \.{\p@barbar} LSTWR \.{:=} lsttmp {\p@semicolon}}%
\@x{\@s{65.6} {\p@if} {\p@lparen} WRTFLG \.{=} \.{-} 1 {\p@rparen}}%
\@x{\@s{65.6} {\p@lbrace}}%
\@x{\@s{73.79} WRTFLG \.{:=} self {\p@semicolon}}%
\@x{\@s{65.6} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{57.4} {\p@rbrace}}%
\@x{\@s{49.2} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{49.2} {\p@if} {\p@lparen} WRTFLG \.{\neq} self {\p@rparen}}%
\@x{\@s{49.2} {\p@lbrace}}%
\@x{\@s{57.4} tail \.{:=} GetTail {\p@semicolon}}%
 \@x{\@s{57.4} msg [ tail ] \.{:=} [ ver \.{\mapsto} \.{-} 1 ,\, val
 \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto} self ] {\p@semicolon}}%
\@x{\@s{49.2} {\p@rbrace}}%
\@x{\@s{41.0} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{41.0} CLW\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{41.0} {\p@while} {\p@lparen} WRTFLG \.{=} self {\p@rparen}}%
\@y{\@s{0}%
 Iterate through write request
}%
\@xx{}%
\@x{\@s{41.0} {\p@lbrace}}%
 \@x{\@s{49.2} {\p@if} {\p@lparen} msg [ self ] . val \.{\neq} \.{-} 1
 \.{\land} msg [ self ] . ver \.{=} hver {\p@rparen}}%
\@x{\@s{49.2} {\p@lbrace}}%
\@x{\@s{57.4} lsttmp \.{:=} msg [ self ] . ver {\p@semicolon}}%
\@x{\@s{57.4} cntr \.{:=} cntr \.{+} 1 {\p@semicolon}}%
\@x{\@s{57.4} WRTFLG \.{:=} \.{-} 1 {\p@semicolon}}%
\@x{\@s{49.2} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{49.2} {\p@if} {\p@lparen} WRTFLG \.{=} self {\p@rparen}}%
\@x{\@s{49.2} {\p@lbrace}}%
\@x{\@s{57.4} head \.{:=} GetHead {\p@semicolon}}%
 \@x{\@s{57.4} msg [ head ] \.{:=} [ ver \.{\mapsto} hver ,\, val \.{\mapsto}
 cntr ,\, cli \.{\mapsto} self ] {\p@semicolon}}%
\@x{\@s{49.2} {\p@rbrace}}%
\@x{\@s{41.0} {\p@rbrace}}%
\@x{\@s{32.8} {\p@rbrace}}%
\@x{\@s{16.4} {\p@rbrace}}%
\@x{\@s{16.4} {\p@fair} {\p@process} {\p@lparen} n \.{\in} Nodes {\p@rparen}}%
 \@x{\@s{16.4} {\p@variable} nextnode \.{=} \.{-} 1 ,\, clientid \.{=} 0
 {\p@semicolon}}%
\@x{\@s{16.4} {\p@lbrace}}%
 \@x{\@s{24.59} ND\@s{.5}\textrm{:}\@s{3} {\p@while} {\p@lparen} {\TRUE}
 {\p@rparen}}%
\@x{\@s{24.59} {\p@lbrace}}%
\@x{\@s{32.8} {\p@either}}%
\@x{\@s{32.8} NM\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@lbrace}}%
\@y{\@s{0}%
 react to message
}%
\@xx{}%
 \@x{\@s{42.38} {\p@if} {\p@lparen} up [ self ] \.{=} {\TRUE} \.{\land} msg [
 self ] \.{\neq} {\langle} {\rangle} \.{\land} InChain ( self ) \.{=} {\TRUE}
 {\p@rparen}}%
\@x{\@s{42.38} {\p@lbrace}}%
\@x{\@s{50.58} clientid \.{:=} msg [ self ] . cli {\p@semicolon}}%
 \@x{\@s{50.58} {\p@if} {\p@lparen} msg [ self ] . val \.{=} \.{-} 1 \.{\land}
 self \.{=} GetTail {\p@rparen}}%
\@y{\@s{0}%
 handling Read message request
}%
\@xx{}%
\@x{\@s{50.58} {\p@lbrace}}%
 \@x{\@s{58.78} msg [ clientid ] \.{:=} [ ver \.{\mapsto} db [ self ] . ver
 ,\, val \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto} clientid ] \.{\p@barbar} msg
 [ self ] \.{:=} {\langle} {\rangle} {\p@semicolon}}%
\@x{\@s{50.58} {\p@rbrace}}%
 \@x{\@s{50.58} {\p@else} {\p@if} {\p@lparen} msg [ self ] . val \.{\neq}
 \.{-} 1 {\p@rparen}}%
\@y{\@s{0}%
 handling Write message request
}%
\@xx{}%
\@x{\@s{50.58} {\p@lbrace}}%
 \@x{\@s{58.78} db [ self ] \.{:=} [ ver \.{\mapsto} msg [ self ] . ver ,\,
 val \.{\mapsto} msg [ self ] . val ,\, cli \.{\mapsto} msg [ self ] . cli ]
 {\p@semicolon}}%
\@x{\@s{58.78} {\p@if} {\p@lparen} self \.{=} GetTail {\p@rparen}\@s{28.7}}%
\@y{\@s{0}%
 check if this is a tail node
}%
\@xx{}%
\@x{\@s{58.78} {\p@lbrace}}%
\@x{\@s{66.98} lsttmp \.{:=} db [ self ] . ver {\p@semicolon}}%
 \@x{\@s{66.98} msg [ clientid ] \.{:=} [ ver \.{\mapsto} db [ self ] . ver
 ,\, val \.{\mapsto} db [ self ] . val ,\, cli \.{\mapsto} clientid ]
 \.{\p@barbar} msg [ self ] \.{:=} {\langle} {\rangle} {\p@semicolon}}%
\@x{\@s{58.78} {\p@rbrace}}%
\@x{\@s{58.78} {\p@else}\@s{77.9}}%
\@y{\@s{0}%
 else get the successor
}%
\@xx{}%
\@x{\@s{58.78} {\p@lbrace}}%
\@x{\@s{66.98} nextnode \.{:=} GetNext ( self ) {\p@semicolon}}%
 \@x{\@s{66.98} msg [ nextnode ] \.{:=} msg [ self ] \.{\p@barbar} msg [ self
 ] \.{:=} {\langle} {\rangle} {\p@semicolon}}%
\@x{\@s{58.78} {\p@rbrace}}%
\@x{\@s{50.58} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{42.38} {\p@rbrace}}%
\@x{\@s{32.8} {\p@rbrace} {\p@or}}%
\@x{\@s{32.8} NDF\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@lbrace}}%
 \@x{\@s{41.0} {\p@if} {\p@lparen} FailNum \.{>} 0 \.{\land} up [ self ] \.{=}
 {\TRUE} {\p@rparen}}%
\@y{%
 Storage node can fail
}%
\@xx{}%
\@x{\@s{41.0} {\p@lbrace}}%
\@x{\@s{49.2} up [ self ] \.{:=} {\FALSE} {\p@semicolon}}%
\@x{\@s{49.2} FailNum \.{:=} FailNum \.{-} 1 {\p@semicolon}}%
\@x{\@s{41.0} {\p@rbrace}}%
 \@x{\@s{41.0} {\p@else} {\p@if} {\p@lparen} up [ self ] \.{=} {\FALSE}
 {\p@rparen}\@s{4.1}}%
\@y{%
 Or recover as a new node
}%
\@xx{}%
\@x{\@s{41.0} {\p@lbrace}}%
\@x{\@s{49.2} up [ self ]\@s{6.64} \.{:=} {\TRUE} {\p@semicolon}}%
 \@x{\@s{49.2} msg [ self ] \.{:=} {\langle} {\rangle}\@s{15.64}
 {\p@semicolon}}%
\@x{\@s{49.2} FailNum \.{:=} FailNum \.{+} 1 {\p@semicolon}}%
\@x{\@s{41.0} {\p@rbrace}}%
\@x{\@s{32.8} {\p@rbrace}}%
\@x{\@s{24.59} {\p@rbrace}}%
\@x{\@s{16.4} {\p@rbrace}}%
 \@x{\@s{16.4} {\p@fair} {\p@process} {\p@lparen} p \.{=} Configurator
 {\p@rparen}}%
\@y{\@s{0}%
 Maintain the chain
}%
\@xx{}%
\@x{\@s{16.4} {\p@variable} newnode \.{=} \.{-} 1 {\p@semicolon}}%
\@x{\@s{16.4} {\p@lbrace}}%
 \@x{\@s{24.59} P\@s{.5}\textrm{:}\@s{3} {\p@while} {\p@lparen} {\TRUE}
 {\p@rparen}}%
\@x{\@s{24.59} {\p@lbrace}}%
\@x{\@s{32.8} P1\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@if} {\p@lparen} Len ( chain ) \.{<} 3 {\p@rparen}}%
\@y{%
 Add a new node
}%
\@xx{}%
\@x{\@s{32.8} {\p@lbrace}}%
\@x{\@s{41.0} {\p@if} {\p@lparen} FreeUpNodes \.{\neq} \{ \} {\p@rparen}}%
\@x{\@s{41.0} {\p@lbrace}}%
 \@x{\@s{49.2} newnode \.{:=} {\CHOOSE} k \.{\in} FreeUpNodes \.{:} {\TRUE}
 {\p@semicolon}}%
\@x{\@s{49.2} {\p@if} {\p@lparen} Len ( chain ) \.{=} 0 {\p@rparen}}%
\@x{\@s{49.2} {\p@lbrace}}%
 \@x{\@s{57.4} db [ newnode ] \.{:=} [ ver \.{\mapsto} \.{-} 1 ,\, val
 \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto} 0 ] {\p@semicolon}}%
\@x{\@s{57.4} chain \.{:=} Append ( chain ,\, newnode ) {\p@semicolon}}%
\@x{\@s{49.2} {\p@rbrace}}%
\@x{\@s{49.2} {\p@else}}%
\@x{\@s{49.2} {\p@lbrace}}%
 \@x{\@s{57.4} db [ newnode ] \.{:=} db [ chain [ Len ( chain ) ] ]
 {\p@semicolon}}%
\@x{\@s{57.4} chain \.{:=} Append ( chain ,\, newnode ) {\p@semicolon}}%
\@x{\@s{49.2} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{41.0} {\p@rbrace} {\p@semicolon}}%
\@x{\@s{32.8} {\p@rbrace}}%
\@x{\@s{32.8} {\p@else}}%
\@y{\@s{0}%
 Delete fail node
}%
\@xx{}%
\@x{\@s{32.8} {\p@lbrace}}%
\@x{\@s{41.0} chain \.{:=} SelectSeq ( chain ,\, test ) {\p@semicolon}}%
\@x{\@s{32.8} {\p@rbrace}}%
\@x{\@s{24.59} {\p@rbrace}}%
\@x{\@s{16.4} {\p@rbrace}}%
\@x{ {\p@rbrace}}%
\@y{}%
\@xx{}%
\pcalshadingfalse \pcalsymbolsfalse
\@x{}%
\@y{\@s{0}%
 BEGIN TRANSLATION
}%
\@xx{}%
 \@x{ {\VARIABLES} FailNum ,\, step ,\, LSTWR ,\, CURRD ,\, lsttmp ,\, WRTFLG
 ,\, msg ,\, up ,\, db ,\, chain ,\, pc}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 define statement
}%
\@xx{}%
\@x{ UpNodes \.{\defeq} \{ i \.{\in} Nodes \.{:} up [ i ] \.{=} {\TRUE} \}}%
 \@x{ ChainNode \.{\defeq} \{ chain [ i ] \.{:} i \.{\in} 1 \.{\dotdot} Len (
 chain ) \}}%
 \@x{ ChainNodes \.{\defeq} {\IF} ( Len ( chain ) \.{=} 0 ) \.{\THEN} \{ \.{-}
 1 \} \.{\ELSE} ChainNode}%
 \@x{ InChain ( s )\@s{3.72} \.{\defeq} {\IF} ( s \.{\in} ChainNodes )
 \.{\THEN} {\TRUE} \.{\ELSE} {\FALSE}}%
 \@x{ FreeUpNodes \.{\defeq} \{ i \.{\in} UpNodes \.{:} InChain ( i ) \.{=}
 {\FALSE} \.{\land} up [ i ] \.{=} {\TRUE} \}}%
 \@x{ GetIndex ( s )\@s{3.97} \.{\defeq} {\CHOOSE} i \.{\in} 1 \.{\dotdot} Len
 ( chain ) \.{:} chain [ i ] \.{=} s}%
 \@x{ GetNext ( s ) \.{\defeq} {\IF} ( GetIndex ( s ) \.{=} Len ( chain ) )
 \.{\THEN} \.{-} 1 \.{\ELSE} chain [ GetIndex ( s ) \.{+} 1 ]}%
 \@x{ GetFreeNode \.{\defeq} \{ i \.{\in} FreeUpNodes \.{:} up [ i ] \.{=}
 {\TRUE} \}}%
\@x{ GetTail\@s{4.62} \.{\defeq} chain [ Len ( chain ) ]}%
\@x{ GetHead \.{\defeq} chain [ 1 ]}%
 \@x{ test ( e )\@s{9.02} \.{\defeq} {\IF} ( up [ e ] \.{=} {\TRUE} )
 \.{\THEN} {\TRUE} \.{\ELSE} {\FALSE}}%
\@pvspace{8.0pt}%
 \@x{ {\VARIABLES} cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\, initial ,\,
 nextnode ,\, clientid ,\,}%
\@x{\@s{51.42} newnode}%
\@pvspace{8.0pt}%
 \@x{ vars \.{\defeq} {\langle} FailNum ,\, step ,\, LSTWR ,\, CURRD ,\,
 lsttmp ,\, WRTFLG ,\, msg ,\, up ,\, db ,\, chain ,\,}%
 \@x{\@s{41.61} pc ,\, cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\, initial
 ,\, nextnode ,\, clientid ,\,}%
\@x{\@s{41.61} newnode {\rangle}}%
\@pvspace{8.0pt}%
 \@x{ ProcSet \.{\defeq} ( Clients ) \.{\cup} ( Nodes ) \.{\cup} \{
 Configurator \}}%
\@pvspace{8.0pt}%
\@x{ Init \.{\defeq}}%
\@y{\@s{0}%
 Global variables
}%
\@xx{}%
\@x{\@s{35.70} \.{\land} FailNum \.{=} FAILNUM}%
\@x{\@s{35.70} \.{\land} step \.{=} 0}%
\@x{\@s{35.70} \.{\land} LSTWR\@s{0.94} \.{=} \.{-} 1}%
\@x{\@s{35.70} \.{\land} CURRD \.{=} \.{-} 1}%
\@x{\@s{35.70} \.{\land} lsttmp\@s{17.87} \.{=} \.{-} 1}%
\@x{\@s{35.70} \.{\land} WRTFLG \.{=} \.{-} 1}%
 \@x{\@s{35.70} \.{\land} msg \.{=} [ j \.{\in} Procs \.{\mapsto} {\langle}
 {\rangle} ]}%
\@x{\@s{35.70} \.{\land} up \.{=} [ n \.{\in} Nodes \.{\mapsto} {\TRUE} ]}%
 \@x{\@s{35.70} \.{\land} db\@s{0.76} \.{=} [ n \.{\in} Nodes \.{\mapsto} [
 ver \.{\mapsto} \.{-} 1 ,\, val \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto}
 \.{-} 1 ] ]}%
\@x{\@s{35.70} \.{\land} chain \.{=} {\langle} {\rangle}}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
 Process \ensuremath{c
}}%
\@xx{}%
 \@x{\@s{35.70} \.{\land} cntr\@s{0.76} \.{=} [ self \.{\in} Clients
 \.{\mapsto} 0 ]}%
 \@x{\@s{35.70} \.{\land} hver \.{=} [ self \.{\in} Clients \.{\mapsto} \.{-}
 1 ]}%
 \@x{\@s{35.70} \.{\land} lastelm \.{=} [ self \.{\in} Clients \.{\mapsto} 0
 ]}%
 \@x{\@s{35.70} \.{\land} tail\@s{5.36} \.{=} [ self \.{\in} Clients
 \.{\mapsto} \.{-} 1 ]}%
 \@x{\@s{35.70} \.{\land} head \.{=} [ self \.{\in} Clients \.{\mapsto} \.{-}
 1 ]}%
 \@x{\@s{35.70} \.{\land} initial \.{=} [ self \.{\in} Clients \.{\mapsto} 0
 ]}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
 Process \ensuremath{n
}}%
\@xx{}%
 \@x{\@s{35.70} \.{\land} nextnode \.{=} [ self \.{\in} Nodes \.{\mapsto}
 \.{-} 1 ]}%
 \@x{\@s{35.70} \.{\land} clientid\@s{5.89} \.{=} [ self \.{\in} Nodes
 \.{\mapsto} 0 ]}%
\@x{\@s{35.70}}%
\@y{\@s{0}%
 Process \ensuremath{p
}}%
\@xx{}%
\@x{\@s{35.70} \.{\land} newnode \.{=} \.{-} 1}%
 \@x{\@s{35.70} \.{\land} pc \.{=} [ self \.{\in} ProcSet \.{\mapsto} {\CASE}
 self \.{\in} Clients \.{\rightarrow}\@w{C0}}%
\@x{\@s{160.39} {\Box}\@s{10.30} self \.{\in} Nodes \.{\rightarrow}\@w{ND}}%
 \@x{\@s{160.39} {\Box}\@s{10.30} self \.{=} Configurator
 \.{\rightarrow}\@w{P} ]}%
\@pvspace{8.0pt}%
\@x{ C0 ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{C0}}%
\@x{\@s{56.70} \.{\land} ( Len ( chain ) \.{>} 0 )}%
 \@x{\@s{56.70} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
 \.{=}\@w{CL} ]}%
 \@x{\@s{56.70} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, lsttmp ,\, WRTFLG ,\, msg ,\,}%
 \@x{\@s{130.29} up ,\, db ,\, chain ,\, cntr ,\, hver ,\, lastelm ,\, tail
 ,\, head ,\,}%
\@x{\@s{130.29} initial ,\, nextnode ,\, clientid ,\, newnode {\rangle}}%
\@pvspace{8.0pt}%
\@x{ CL ( self )\@s{0.18} \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{CL}}%
\@x{\@s{56.70} \.{\land} {\IF} cntr [ self ] \.{\leq} STOP}%
 \@x{\@s{79.97} \.{\THEN} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{CLR} ]}%
 \@x{\@s{79.97} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{Done} ]}%
 \@x{\@s{56.70} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, lsttmp ,\, WRTFLG ,\, msg ,\,}%
 \@x{\@s{130.29} up ,\, db ,\, chain ,\, cntr ,\, hver ,\, lastelm ,\, tail
 ,\, head ,\,}%
\@x{\@s{130.29} initial ,\, nextnode ,\, clientid ,\, newnode {\rangle}}%
\@pvspace{8.0pt}%
 \@x{ CLR ( self )\@s{3.12} \.{\defeq} \.{\land} pc [ self ]\@s{25.48}
 \.{=}\@w{CLR}}%
\@x{\@s{67.32} \.{\land} {\IF} WRTFLG \.{\neq} self}%
 \@x{\@s{90.59} \.{\THEN} \.{\land} {\IF} msg [ self ] \.{\neq} {\langle}
 {\rangle}}%
 \@x{\@s{145.17} \.{\THEN} \.{\land} {\IF} msg [ self ] . val\@s{9.01} \.{=}
 \.{-} 1}%
 \@x{\@s{199.74} \.{\THEN} \.{\land} hver \.{'} \.{=} [ hver {\EXCEPT} {\bang}
 [ self ] \.{=} msg [ self ] . ver \.{+} 1 ]}%
 \@x{\@s{231.05} \.{\land} \.{\land} CURRD \.{'} \.{=} db [ chain [ Len (
 chain ) ] ] . ver}%
\@x{\@s{242.17} \.{\land} LSTWR \.{'}\@s{0.94} \.{=} lsttmp}%
\@x{\@s{231.05} \.{\land} {\IF} WRTFLG \.{=} \.{-} 1}%
\@x{\@s{254.32} \.{\THEN} \.{\land} WRTFLG \.{'} \.{=} self}%
\@x{\@s{254.32} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{285.63} \.{\land} {\UNCHANGED} WRTFLG}%
\@x{\@s{199.74} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{231.05} \.{\land} {\UNCHANGED} {\langle} LSTWR ,\, CURRD ,\,}%
\@x{\@s{304.64} WRTFLG ,\, hver {\rangle}}%
\@x{\@s{145.17} \.{\ELSE} \.{\land} {\TRUE}}%
 \@x{\@s{176.48} \.{\land} {\UNCHANGED} {\langle} LSTWR ,\, CURRD ,\, WRTFLG
 ,\, hver {\rangle}}%
\@x{\@s{121.90} \.{\land} {\IF} WRTFLG \.{'} \.{\neq} self}%
 \@x{\@s{145.17} \.{\THEN} \.{\land} tail \.{'} \.{=} [ tail {\EXCEPT} {\bang}
 [ self ] \.{=} GetTail ]}%
 \@x{\@s{176.48} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [ tail
 \.{'} [ self ] ] \.{=} [ ver \.{\mapsto} \.{-} 1 ,\, val \.{\mapsto} \.{-} 1
 ,\, cli \.{\mapsto} self ] ]}%
\@x{\@s{145.17} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{176.48} \.{\land} {\UNCHANGED} {\langle} msg ,\, tail {\rangle}}%
 \@x{\@s{121.90} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
 \.{=}\@w{CLR} ]}%
 \@x{\@s{90.59} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{CLW} ]}%
 \@x{\@s{121.90} \.{\land} {\UNCHANGED} {\langle} LSTWR ,\, CURRD ,\, WRTFLG
 ,\, msg ,\, hver ,\, tail {\rangle}}%
 \@x{\@s{67.32} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, lsttmp
 ,\, up ,\, db ,\, chain ,\, cntr ,\,}%
\@x{\@s{140.91} lastelm ,\, head ,\, initial ,\, nextnode ,\, clientid ,\,}%
\@x{\@s{140.91} newnode {\rangle}}%
\@pvspace{8.0pt}%
\@x{ CLW ( self ) \.{\defeq} \.{\land} pc [ self ]\@s{25.48} \.{=}\@w{CLW}}%
\@x{\@s{67.32} \.{\land} {\IF} WRTFLG \.{=} self}%
 \@x{\@s{90.59} \.{\THEN} \.{\land} {\IF} msg [ self ] . val \.{\neq} \.{-} 1
 \.{\land} msg [ self ] . ver \.{=} hver [ self ]}%
\@x{\@s{145.17} \.{\THEN} \.{\land} lsttmp \.{'} \.{=} msg [ self ] . ver}%
 \@x{\@s{176.48} \.{\land} cntr \.{'} \.{=} [ cntr {\EXCEPT} {\bang} [ self ]
 \.{=} cntr [ self ] \.{+} 1 ]}%
\@x{\@s{176.48} \.{\land} WRTFLG \.{'} \.{=} \.{-} 1}%
\@x{\@s{145.17} \.{\ELSE} \.{\land} {\TRUE}}%
 \@x{\@s{176.48} \.{\land} {\UNCHANGED} {\langle} lsttmp ,\, WRTFLG ,\, cntr
 {\rangle}}%
\@x{\@s{121.90} \.{\land} {\IF} WRTFLG \.{'} \.{=} self}%
 \@x{\@s{145.17} \.{\THEN} \.{\land} head \.{'} \.{=} [ head {\EXCEPT} {\bang}
 [ self ] \.{=} GetHead ]}%
 \@x{\@s{176.48} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [ head
 \.{'} [ self ] ] \.{=} [ ver \.{\mapsto} hver [ self ] ,\, val \.{\mapsto}
 cntr \.{'} [ self ] ,\, cli \.{\mapsto} self ] ]}%
\@x{\@s{145.17} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{176.48} \.{\land} {\UNCHANGED} {\langle} msg ,\, head {\rangle}}%
 \@x{\@s{121.90} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
 \.{=}\@w{CLW} ]}%
 \@x{\@s{90.59} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{CL} ]}%
 \@x{\@s{121.90} \.{\land} {\UNCHANGED} {\langle} lsttmp ,\, WRTFLG ,\, msg
 ,\, cntr ,\, head {\rangle}}%
 \@x{\@s{67.32} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, up ,\, db ,\, chain ,\, hver ,\,}%
\@x{\@s{140.91} lastelm ,\, tail ,\, initial ,\, nextnode ,\, clientid ,\,}%
\@x{\@s{140.91} newnode {\rangle}}%
\@pvspace{8.0pt}%
 \@x{ c ( self ) \.{\defeq} C0 ( self ) \.{\lor} CL ( self ) \.{\lor} CLR (
 self ) \.{\lor} CLW ( self )}%
\@pvspace{8.0pt}%
\@x{ ND ( self )\@s{2.11} \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{ND}}%
 \@x{\@s{61.13} \.{\land} \.{\lor} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT}
 {\bang} [ self ] \.{=}\@w{NM} ]}%
 \@x{\@s{72.24} \.{\lor} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{NDF} ]}%
 \@x{\@s{61.13} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, lsttmp ,\, WRTFLG ,\, msg ,\,}%
 \@x{\@s{134.72} up ,\, db ,\, chain ,\, cntr ,\, hver ,\, lastelm ,\, tail
 ,\, head ,\,}%
\@x{\@s{134.72} initial ,\, nextnode ,\, clientid ,\, newnode {\rangle}}%
\@pvspace{8.0pt}%
\@x{ NM ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{NM}}%
 \@x{\@s{61.13} \.{\land} {\IF} up [ self ] \.{=} {\TRUE} \.{\land} msg [ self
 ] \.{\neq} {\langle} {\rangle} \.{\land} InChain ( self ) \.{=} {\TRUE}}%
 \@x{\@s{84.40} \.{\THEN} \.{\land} clientid \.{'} \.{=} [ clientid {\EXCEPT}
 {\bang} [ self ] \.{=} msg [ self ] . cli ]}%
 \@x{\@s{115.71} \.{\land} {\IF} msg [ self ] . val\@s{7.16} \.{=} \.{-} 1
 \.{\land} self \.{=} GetTail}%
 \@x{\@s{138.97} \.{\THEN} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [
 clientid \.{'} [ self ] ] \.{=} [ ver \.{\mapsto} db [ self ] . ver ,\, val
 \.{\mapsto} \.{-} 1 ,\, cli \.{\mapsto} clientid \.{'} [ self ] ] ,\,}%
\@x{\@s{277.84} {\bang} [ self ] \.{=} {\langle} {\rangle} ]}%
 \@x{\@s{170.29} \.{\land} {\UNCHANGED} {\langle} lsttmp ,\, db ,\, nextnode
 {\rangle}}%
 \@x{\@s{138.97} \.{\ELSE} \.{\land} {\IF} msg [ self ] . val \.{\neq} \.{-}
 1}%
 \@x{\@s{193.55} \.{\THEN} \.{\land} db \.{'} \.{=} [ db {\EXCEPT} {\bang} [
 self ] \.{=} [ ver \.{\mapsto} msg [ self ] . ver ,\, val \.{\mapsto} msg [
 self ] . val ,\, cli \.{\mapsto} msg [ self ] . cli ] ]}%
\@x{\@s{224.86} \.{\land} {\IF} self \.{=} GetTail}%
 \@x{\@s{248.13} \.{\THEN} \.{\land} lsttmp \.{'} \.{=} db \.{'} [ self ] .
 ver}%
 \@x{\@s{279.44} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [ clientid
 \.{'} [ self ] ] \.{=} [ ver \.{\mapsto} db \.{'} [ self ] . ver ,\, val
 \.{\mapsto} db \.{'} [ self ] . val ,\, cli \.{\mapsto} clientid \.{'} [
 self ] ] ,\,}%
\@x{\@s{386.99} {\bang} [ self ] \.{=} {\langle} {\rangle} ]}%
\@x{\@s{279.44} \.{\land} {\UNCHANGED} nextnode}%
 \@x{\@s{248.13} \.{\ELSE} \.{\land} nextnode \.{'} \.{=} [ nextnode {\EXCEPT}
 {\bang} [ self ] \.{=} GetNext ( self ) ]}%
 \@x{\@s{279.44} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [ nextnode
 \.{'} [ self ] ] \.{=} msg [ self ] ,\,}%
\@x{\@s{386.99} {\bang} [ self ] \.{=} {\langle} {\rangle} ]}%
\@x{\@s{279.44} \.{\land} {\UNCHANGED} lsttmp}%
\@x{\@s{193.55} \.{\ELSE} \.{\land} {\TRUE}}%
\@x{\@s{224.86} \.{\land} {\UNCHANGED} {\langle} lsttmp ,\, msg ,\, db ,\,}%
\@x{\@s{298.45} nextnode {\rangle}}%
\@x{\@s{84.40} \.{\ELSE} \.{\land} {\TRUE}}%
 \@x{\@s{115.71} \.{\land} {\UNCHANGED} {\langle} lsttmp ,\, msg ,\, db ,\,
 nextnode ,\, clientid {\rangle}}%
 \@x{\@s{61.13} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
 \.{=}\@w{ND} ]}%
 \@x{\@s{61.13} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, WRTFLG ,\, up ,\, chain ,\,}%
 \@x{\@s{134.72} cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\, initial ,\,
 newnode {\rangle}}%
\@pvspace{8.0pt}%
\@x{ NDF ( self ) \.{\defeq} \.{\land} pc [ self ] \.{=}\@w{NDF}}%
 \@x{\@s{65.93} \.{\land} {\IF} FailNum \.{>} 0 \.{\land} up [ self ] \.{=}
 {\TRUE}}%
 \@x{\@s{89.20} \.{\THEN} \.{\land} up \.{'} \.{=} [ up {\EXCEPT} {\bang} [
 self ] \.{=} {\FALSE} ]}%
\@x{\@s{120.51} \.{\land} FailNum \.{'} \.{=} FailNum \.{-} 1}%
\@x{\@s{120.51} \.{\land} msg \.{'} \.{=} msg}%
\@x{\@s{89.20} \.{\ELSE} \.{\land} {\IF} up [ self ] \.{=} {\FALSE}}%
 \@x{\@s{143.78} \.{\THEN} \.{\land} up \.{'} \.{=} [ up {\EXCEPT} {\bang} [
 self ] \.{=} {\TRUE} ]}%
 \@x{\@s{175.09} \.{\land} msg \.{'} \.{=} [ msg {\EXCEPT} {\bang} [ self ]
 \.{=} {\langle} {\rangle} ]}%
\@x{\@s{175.09} \.{\land} FailNum \.{'} \.{=} FailNum \.{+} 1}%
\@x{\@s{143.78} \.{\ELSE} \.{\land} {\TRUE}}%
 \@x{\@s{175.09} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, msg ,\, up
 {\rangle}}%
 \@x{\@s{65.93} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ self ]
 \.{=}\@w{ND} ]}%
 \@x{\@s{65.93} \.{\land} {\UNCHANGED} {\langle} step ,\, LSTWR ,\, CURRD ,\,
 lsttmp ,\, WRTFLG ,\, db ,\, chain ,\,}%
\@x{\@s{139.52} cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\, initial ,\,}%
\@x{\@s{139.52} nextnode ,\, clientid ,\, newnode {\rangle}}%
\@pvspace{8.0pt}%
 \@x{ n ( self ) \.{\defeq} ND ( self ) \.{\lor} NM ( self ) \.{\lor} NDF (
 self )}%
\@pvspace{8.0pt}%
\@x{ P \.{\defeq} \.{\land} pc [ Configurator ] \.{=}\@w{P}}%
 \@x{\@s{26.69} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ Configurator
 ] \.{=}\@w{P1} ]}%
 \@x{\@s{26.69} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, lsttmp ,\, WRTFLG ,\, msg ,\, up ,\, db ,\,}%
 \@x{\@s{100.28} chain ,\, cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\,
 initial ,\, nextnode ,\,}%
\@x{\@s{100.28} clientid ,\, newnode {\rangle}}%
\@pvspace{8.0pt}%
\@x{ P1 \.{\defeq} \.{\land} pc [ Configurator ] \.{=}\@w{P1}}%
\@x{\@s{31.69} \.{\land} {\IF} Len ( chain ) \.{<} 3}%
\@x{\@s{54.96} \.{\THEN} \.{\land} {\IF} FreeUpNodes \.{\neq} \{ \}}%
 \@x{\@s{109.54} \.{\THEN} \.{\land} newnode \.{'} \.{=} ( {\CHOOSE} k \.{\in}
 FreeUpNodes \.{:} {\TRUE} )}%
\@x{\@s{140.85} \.{\land} {\IF} Len ( chain ) \.{=} 0}%
 \@x{\@s{164.11} \.{\THEN} \.{\land} db \.{'} \.{=} [ db {\EXCEPT} {\bang} [
 newnode \.{'} ] \.{=} [ ver \.{\mapsto} \.{-} 1 ,\, val \.{\mapsto} \.{-} 1
 ,\, cli \.{\mapsto} 0 ] ]}%
 \@x{\@s{195.42} \.{\land} chain \.{'} \.{=} Append ( chain ,\, newnode \.{'}
 )}%
 \@x{\@s{164.11} \.{\ELSE} \.{\land} db \.{'} \.{=} [ db {\EXCEPT} {\bang} [
 newnode \.{'} ] \.{=} db [ chain [ Len ( chain ) ] ] ]}%
 \@x{\@s{195.42} \.{\land} chain \.{'} \.{=} Append ( chain ,\, newnode \.{'}
 )}%
\@x{\@s{109.54} \.{\ELSE} \.{\land} {\TRUE}}%
 \@x{\@s{140.85} \.{\land} {\UNCHANGED} {\langle} db ,\, chain ,\, newnode
 {\rangle}}%
 \@x{\@s{54.96} \.{\ELSE} \.{\land} chain \.{'} \.{=} SelectSeq ( chain ,\,
 test )}%
\@x{\@s{86.27} \.{\land} {\UNCHANGED} {\langle} db ,\, newnode {\rangle}}%
 \@x{\@s{31.69} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [ Configurator
 ] \.{=}\@w{P} ]}%
 \@x{\@s{31.69} \.{\land} {\UNCHANGED} {\langle} FailNum ,\, step ,\, LSTWR
 ,\, CURRD ,\, lsttmp ,\, WRTFLG ,\, msg ,\, up ,\,}%
 \@x{\@s{105.28} cntr ,\, hver ,\, lastelm ,\, tail ,\, head ,\, initial ,\,
 nextnode ,\,}%
\@x{\@s{105.28} clientid {\rangle}}%
\@pvspace{8.0pt}%
\@x{ p \.{\defeq} P \.{\lor} P1}%
\@pvspace{8.0pt}%
\@x{ Next \.{\defeq} p}%
\@x{\@s{52.13} \.{\lor} ( \E\, self \.{\in} Clients \.{:} c ( self ) )}%
\@x{\@s{52.13} \.{\lor} ( \E\, self \.{\in} Nodes \.{:} n ( self ) )}%
\@pvspace{8.0pt}%
 \@x{ Spec\@s{1.46} \.{\defeq} \.{\land} Init \.{\land} {\Box} [ Next ]_{
 vars}}%
 \@x{\@s{39.83} \.{\land} \A\, self \.{\in} Clients \.{:} {\WF}_{ vars} ( c (
 self ) )}%
 \@x{\@s{39.83} \.{\land} \A\, self \.{\in} Nodes \.{:} {\WF}_{ vars} ( n (
 self ) )}%
\@x{\@s{39.83} \.{\land} {\WF}_{ vars} ( p )}%
\@pvspace{8.0pt}%
\@x{}%
\@y{\@s{0}%
 END TRANSLATION
}%
\@xx{}%
\@x{ Invariant1 \.{\defeq} LSTWR \.{=} CURRD}%
 \@x{ Invariant2 \.{\defeq} \A\, i\@s{25.41} \.{\in} 1 \.{\dotdot} ( Len (
 chain ) \.{-} 1 ) \.{:} db [ chain [ i ] ] . ver \.{\geq} db [ chain [ i
 \.{+} 1 ] ] . ver}%
\@pvspace{8.0pt}%
\@x{}\bottombar\@xx{}%
\setboolean{shading}{false}
\begin{lcom}{0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
\ensuremath{\.{\,\backslash\,}}* Modification History
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 \ensuremath{\.{\,\backslash\,}}* Last modified \ensuremath{Thu}
 \ensuremath{Dec} 08 23:49:00 \ensuremath{EST} 2016 by \ensuremath{Rohit
}%
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 \ensuremath{\.{\,\backslash\,}}* Last modified \ensuremath{Thu}
 \ensuremath{Dec} 08 20:27:28 \ensuremath{EST} 2016 by \ensuremath{anand
}%
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 \ensuremath{\.{\,\backslash\,}}* Created \ensuremath{Thu} \ensuremath{Nov} 24
 19:14:19 \ensuremath{EST} 2016 by \ensuremath{anand
}%
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 Members \ensuremath{\.{-} Anand} \ensuremath{Sankar} \ensuremath{Bhagavandas
 \.{-} UB} \ensuremath{id \.{-} 50208048
}%
\end{cpar}%
\begin{cpar}{0}{T}{F}{25.0}{0}{}%
 \ensuremath{Rohit} \ensuremath{Joseph} \ensuremath{Sebastian \.{-} UB}
 \ensuremath{id \.{-} 50204806
}%
\end{cpar}%
\vshade{10.0}%
\begin{cpar}{1}{F}{F}{0}{0}{}%
The code given above implements Replicated Storage with Chain Replication.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
The invariant we have specified are -
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 1) The version number of the last write operation is equal to the version
 number of the current read operation.
\end{cpar}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 2) The second invariant is that the \ensuremath{db.ver} is non-increasing
 when we traverse from head to tail.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
Given below are our observations about this version of the protocol -
\end{cpar}%
\vshade{10.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
Voldchain is capable of tolerating more faults with less number of nodes.
 This is because in the \ensuremath{project1} version of the protocol, the
 condition that the value for \ensuremath{ReadQ} and \ensuremath{WriteQ}
 should be
 atleast one greater than the value of \ensuremath{FAILNUM} ineffect also
 brings up the necessity that the majority of nodes should be up and running.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 eg for the case \ensuremath{\.{-} ReadQ\.{=}3}, \ensuremath{WriteQ\.{=}3},
 \ensuremath{FAILNUM\.{=}2} and Number of \ensuremath{Nodes}
 (\ensuremath{N})\ensuremath{\.{=}3},
 This will bring up an error as there are not enough nodes to satisfy the
 size requirements for \ensuremath{ReadQ} and \ensuremath{WriteQ} if two
 nodes are down.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 In the \ensuremath{VoldChain} protocol, the chain length only needs to be one
 greater than \ensuremath{FAILNUM} and the number of nodes can be equal to
 the chain length.
 This will ensure that atleast one node with the current value is up to serve
 the request of the client.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 The Read quorum is analogus to the tail of the chain. The client sends read
 requests to the tail and the tail responds with
 the value of the version number that is available with it. Since the write
 messages are constantly put in queue, the tail will eventually
 possess the highest version number.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 The Write quorum is analogus to the whole chain. The client contacts the head
 which passes on the message to the other nodes. Eventually all the
 nodes in the chain will possess the updated value.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 The previous relation between the quorum and \ensuremath{FAILNUM} holds in
 this case too. The number of nodes in the chain should be one more than
 \ensuremath{FAILNUM}.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 We have implemented a token based lock system to ensure that the write
 operation is consistent and that another client does not write while
 a write operation is in progress. While in possesion of this token, the
 client keeps sending write message till it gets the confirmation that the
 write operation is completed and the token is released from the client.
\end{cpar}%
\vshade{5.0}%
\begin{cpar}{0}{F}{F}{0}{0}{}%
 The system runs without the use of the aforementioned token system when the
 number of clients \ensuremath{C\.{=}1}. But it doesnot satisfy the invariant
 without the token
 system when \ensuremath{C\.{=}2}.
\end{cpar}%
\end{lcom}%
\end{document}
